ext4: issue async reads on snapshot files

If a file is rewritten and goal blocks is taken by snapshot files,
then async reads on the blocks of the snapshot files are issued.
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 383838e..65398ea 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -209,11 +209,21 @@ struct ext4_allocation_request {
 #define EXT4_MAP_UNWRITTEN	(1 << BH_Unwritten)
 #define EXT4_MAP_BOUNDARY	(1 << BH_Boundary)
 #define EXT4_MAP_UNINIT		(1 << BH_Uninit)
+#ifdef CONFIG_EXT4_FS_AUTO_DEFRAG
+#define EXT4_MAP_AUTO_DEFRAG		(1 << BH_Auto_Defrag)
+#endif
 #ifdef CONFIG_EXT4_FS_SNAPSHOT_HOOKS_DATA
 #define EXT4_MAP_REMAP		(1 << BH_Remap)
+#ifdef CONFIG_EXT4_FS_AUTO_DEFRAG
+#define EXT4_MAP_FLAGS		(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\
+				 EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY |\
+				 EXT4_MAP_UNINIT | EXT4_MAP_REMAP | \
+				 EXT4_MAP_AUTO_DEFRAG)
+#else
 #define EXT4_MAP_FLAGS		(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\
 				 EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY |\
 				 EXT4_MAP_UNINIT | EXT4_MAP_REMAP)
+#endif
 #else
 #define EXT4_MAP_FLAGS		(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\
 				 EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY |\
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 46ed826..ee7264f 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -3289,6 +3289,94 @@ free_blocks:
 }
 #endif
 
+#ifdef CONFIG_EXT4_FS_AUTO_DEFRAG
+/*
+ * This function lookup if the goal blocks of the requested blocks
+ * belong to snapshot,  If so, async reads on the goal blocks are
+ * issued,
+ * @inode: inode to be defragged.
+ * @map:   map info
+ */
+int ext4_auto_defrag_begin(struct inode *inode,
+			    struct ext4_map_blocks *map,
+			    struct ext4_ext_path *path)
+{
+	struct ext4_allocation_request ar;
+	ext4_fsblk_t goal;
+	struct ext4_extent_header *eh;
+	struct ext4_extent *ex;
+	int err = 0, depth;
+
+	if (path == NULL) {
+		path = ext4_ext_find_extent(inode, map->m_lblk, path);
+		if (IS_ERR(path)) {
+			err = PTR_ERR(path);
+			path = NULL;
+			goto out;
+		}
+	}
+
+	depth = ext_depth(inode);
+	eh = path[depth].p_hdr;
+	ex = path[depth].p_ext;
+	if (!ex)
+		return 0;
+
+	if (EXT_FIRST_EXTENT(eh) == ex) {
+		ext4_lblk_t ee_block;
+		ee_block = le32_to_cpu(ex->ee_block);
+		if (ee_block == 0)
+			return;
+		ext4_ext_drop_refs(path);
+		path = ext4_ext_find_extent(inode, ee_block - 1, path);
+		if (IS_ERR(path)) {
+			err = PTR_ERR(path);
+			path = NULL;
+			goto out;
+		}
+	} else
+		path[depth].p_ext -= 1;
+	
+
+	goal = ext4_ext_find_goal(inode, path, map->m_lblk);
+	if ((map->m_flags & EXT4_MAP_MAPPED) && (goal == map->m_pblk))
+		/* no need to */
+		goto out;
+
+	ar.lleft = map->m_lblk;
+	err = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);
+	if (err)
+		goto out;
+	ar.lright = map->m_lblk;
+	err = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);
+	if (err)
+		goto out;
+
+	ar.inode = inode;
+	ar.goal = goal;
+	ar.logical = map->m_lblk;
+	ar.len = map->m_len;
+	/*
+	 * TODO we can not use preallocations here
+	 */
+	ar.flags = EXT4_MB_HINT_DATA | EXT4_MB_HINT_GOAL_ONLY |
+		   EXT4_MB_HINT_PREALLOC;
+
+	goal = ext4_mb_new_blocks(NULL, &ar, &err);
+	if (goal > 0) {
+		map->m_flags |= EXT4_MAP_AUTO_DEFRAG;
+		goto out;
+	}
+
+	goal = ext4_auto_defrag_async_read_blocks(inode, goal, map->m_len);
+	if (goal > 0)
+		map->m_flags |= EXT4_MAP_AUTO_DEFRAG;
+
+out:
+	return err;
+}
+#endif
+
 /*
  * Block allocation/map/preallocation routine for extents based files
  *
@@ -3653,7 +3741,14 @@ out:
 	map->m_flags |= EXT4_MAP_MAPPED;
 	map->m_pblk = newblock;
 	map->m_len = allocated;
+
+#ifdef CONFIG_EXT4_FS_AUTO_DEFRAG
+	if (flags & EXT4_GET_BLOCKS_AUTO_DEFRAG)
+		ext4_auto_defrag_begin(inode, map, path);
+#endif
+
 out2:
+
 	if (path) {
 		ext4_ext_drop_refs(path);
 		kfree(path);
